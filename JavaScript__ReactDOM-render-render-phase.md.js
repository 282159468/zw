(self["webpackChunkzw"]=self["webpackChunkzw"]||[]).push([[2411],{3208:function(e,n,t){"use strict";t.r(n);var r=t(7294),o=t(6089),i=t(5659);t(3132);n["default"]=e=>(r.useEffect((()=>{var n;null!==e&&void 0!==e&&null!==(n=e.location)&&void 0!==n&&n.hash&&o.AnchorLink.scrollToAnchor(decodeURIComponent(e.location.hash.slice(1)))}),[]),r.createElement(r.Fragment,null,r.createElement("div",{className:"markdown"},r.createElement("h1",{id:"reactdomrender-\u521d\u59cb\u6e32\u67d3"},r.createElement(o.AnchorLink,{to:"#reactdomrender-\u521d\u59cb\u6e32\u67d3","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"ReactDOM.render \u521d\u59cb\u6e32\u67d3"),r.createElement(i.Z,{code:"ReactDOM.render(<App />, document.getElementById('root'));",lang:"jsx"}),r.createElement("p",null,"src\\packages\\react-dom\\src\\client\\ReactDOM.js"),r.createElement("p",null,"\u4e11\u7684\u6389\u6e23\u7684\u6d41\u7a0b\u56fe"),r.createElement("img",{src:"/images/react-dom-first-render-diagram.png"}),r.createElement("p",null,"ReactDOM \u63d0\u4f9b\u4e0b\u9762\u63a5\u53e3"),r.createElement(i.Z,{code:"export {\n  // \u6b63\u5f0f\u7248\u7684renderSubtreeIntoContainer\n  createPortal,\n  //   \u5e94\u8be5\u662f\u5728\u975eReact\u4f53\u7cfb\u4e0b\u7684\u6279\u91cf\u66f4\u65b0\u63a5\u53e3\n  batchedUpdates as unstable_batchedUpdates,\n  flushSync,\n  Internals as __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,\n  ReactVersion as version,\n  // Disabled behind disableLegacyReactDOMAPIs\n  findDOMNode,\n  //   ssr\u63a5\u53e3\n  hydrate,\n  render,\n  //   renderSubtreeIntoContainer\u914d\u5957\n  unmountComponentAtNode,\n  // exposeConcurrentModeAPIs\n  //   \u5f02\u6b65\u6e32\u67d3\u521d\u6b21\u6e32\u67d3\n  createRoot,\n  createBlockingRoot,\n  discreteUpdates as unstable_discreteUpdates,\n  flushDiscreteUpdates as unstable_flushDiscreteUpdates,\n  flushControlled as unstable_flushControlled,\n  scheduleHydration as unstable_scheduleHydration,\n  // Disabled behind disableUnstableRenderSubtreeIntoContainer\n  renderSubtreeIntoContainer as unstable_renderSubtreeIntoContainer,\n  // Disabled behind disableUnstableCreatePortal\n  // Temporary alias since we already shipped React 16 RC with it.\n  // TODO: remove in React 17.\n  unstable_createPortal,\n};",lang:"js"}),r.createElement("h2",{id:"render"},r.createElement(o.AnchorLink,{to:"#render","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"render"),r.createElement(i.Z,{code:"export function render(\n  element: React$Element<any>,\n  container: Container,\n  callback: ?Function,\n) {\n  // render\u5176\u5b9e\u5c31\u662f\u6267\u884clegacyRenderSubtreeIntoContainer\uff0c\u5e76\u8fd4\u56de\u4ed6\u7684\u7ed3\u679c\n  return legacyRenderSubtreeIntoContainer(\n    null,\n    element,\n    container,\n    false,\n    callback,\n  );\n}",lang:"js"}),r.createElement("h2",{id:"legacyrendersubtreeintocontainer"},r.createElement(o.AnchorLink,{to:"#legacyrendersubtreeintocontainer","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"legacyRenderSubtreeIntoContainer"),r.createElement(i.Z,{code:"function legacyRenderSubtreeIntoContainer(\n  parentComponent: ?React$Component<any, any>,\n  //   \u9700\u8981\u6e32\u67d3\u7684React Element\n  children: ReactNodeList,\n  // DOM\u5bb9\u5668\n  container: Container,\n  // \u670d\u52a1\u7aef\u6e32\u67d3\u65f6\u6ce8\u6c34\n  forceHydrate: boolean,\n  callback: ?Function,\n) {\n  // TODO: Without `any` type, Flow says \"Property cannot be accessed on any\n  // member of intersection type.\" Whyyyyyy.\n  // \u521d\u6b21\u6e32\u67d3\u65f6DOM\u5bb9\u5668\u4e0a\u80af\u5b9a\u6ca1\u6709_reactRootContainer\u5c5e\u6027\u6240\u4ee5root\u80af\u5b9a\u4e3aundefined\n  let root: RootType = (container._reactRootContainer: any);\n  let fiberRoot;\n  if (!root) {\n    // Initial mount\n    // \u521d\u59cb\u5316\uff0c\u5b9e\u9645\u4e0a\u5c31\u662f\u521b\u5efaFiberRoot\n    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(\n      container,\n      forceHydrate,\n    );\n    fiberRoot = root._internalRoot;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Initial mount should not be batched.\n    unbatchedUpdates(() => {\n      updateContainer(children, fiberRoot, parentComponent, callback);\n    });\n  } else {\n    fiberRoot = root._internalRoot;\n    if (typeof callback === 'function') {\n      const originalCallback = callback;\n      callback = function() {\n        const instance = getPublicRootInstance(fiberRoot);\n        originalCallback.call(instance);\n      };\n    }\n    // Update\n    updateContainer(children, fiberRoot, parentComponent, callback);\n  }\n  return getPublicRootInstance(fiberRoot);\n}",lang:"js"}),r.createElement("h2",{id:"legacycreaterootfromdomcontainer"},r.createElement(o.AnchorLink,{to:"#legacycreaterootfromdomcontainer","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"legacyCreateRootFromDOMContainer"),r.createElement(i.Z,{code:"function legacyCreateRootFromDOMContainer(\n  container: Container,\n  forceHydrate: boolean,\n): RootType {\n  // \u5224\u65ad\u662f\u5426\u662f\u670d\u52a1\u7aef\u6e32\u67d3\n  const shouldHydrate =\n    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);\n  // First clear any existing content.\n  //\u5ba2\u6237\u7aef\u6e32\u67d3\u5faa\u73af\u6e05\u7a7aDOM container\uff0c\n  //   ReactDOM.render(<App />, document.getElementById('root'));\n  //   \u5c31\u662f\u6e05\u7a7a#root\u4e0b\u9762\u7684DOM\u8282\u70b9\n  if (!shouldHydrate) {\n    let warned = false;\n    let rootSibling;\n    while ((rootSibling = container.lastChild)) {\n      container.removeChild(rootSibling);\n    }\n  }\n\n  return createLegacyRoot(\n    container,\n    shouldHydrate\n      ? {\n          hydrate: true,\n        }\n      : undefined,\n  );\n}",lang:"js"}),r.createElement(i.Z,{code:"export function createLegacyRoot(\n  container: Container,\n  options?: RootOptions,\n): RootType {\n  // LegacyRoot\u662f\u4e00\u4e2a\u5e38\u91cf\u6807\u8bc6\n  //   export const LegacyRoot = 0;\n  //   export const BlockingRoot = 1;\n  //   export const ConcurrentRoot = 2;\n  return new ReactDOMBlockingRoot(container, LegacyRoot, options);\n}",lang:"js"}),r.createElement(i.Z,{code:"function ReactDOMBlockingRoot(\n  container: Container,\n  tag: RootTag,\n  options: void | RootOptions,\n) {\n  // \u8fd9\u4e2a\u5176\u5b9e\u5c31\u662ffiberRoot\n  this._internalRoot = createRootImpl(container, tag, options);\n}",lang:"js"}),r.createElement(i.Z,{code:"function createRootImpl(\n  container: Container,\n  tag: RootTag,\n  options: void | RootOptions,\n) {\n  // Tag is either LegacyRoot or Concurrent Root\n  const hydrate = options != null && options.hydrate === true;\n  const hydrationCallbacks =\n    (options != null && options.hydrationOptions) || null;\n  // tag\u5c31\u662f\u4e0a\u9762\u7684LegacyRoot\u5e38\u91cf\n  const root = createContainer(container, tag, hydrate, hydrationCallbacks);\n  // \u628afiber.current\u5b58\u5230container\u4e0a\n  markContainerAsRoot(root.current, container);\n  // ...\n  return root;\n}",lang:"js"}),r.createElement("h2",{id:"createcontainer"},r.createElement(o.AnchorLink,{to:"#createcontainer","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"createContainer"),r.createElement(i.Z,{code:"export function createContainer(\n  containerInfo: Container,\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): OpaqueRoot {\n  return createFiberRoot(containerInfo, tag, hydrate, hydrationCallbacks);\n}",lang:"js"}),r.createElement("h2",{id:"createfiberroot"},r.createElement(o.AnchorLink,{to:"#createfiberroot","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"createFiberRoot"),r.createElement(i.Z,{code:"export function createFiberRoot(\n  containerInfo: any,\n  //   tag\u4f9d\u7136\u8fd8\u662f\u4e0a\u9762\u7684LegacyRoot\u5e38\u91cf\n  tag: RootTag,\n  hydrate: boolean,\n  hydrationCallbacks: null | SuspenseHydrationCallbacks,\n): FiberRoot {\n  // FiberRootNode\u5c31\u662f\u521b\u5efafiber\u6839\u8282\u70b9\u7684\u5de5\u5382\n  const root: FiberRoot = (new FiberRootNode(containerInfo, tag, hydrate): any);\n  if (enableSuspenseCallback) {\n    root.hydrationCallbacks = hydrationCallbacks;\n  }\n\n  // Cyclic construction. This cheats the type system right now because\n  // stateNode is any.\n  // \u521b\u5efa\u6839Fiber\n  const uninitializedFiber = createHostRootFiber(tag);\n  root.current = uninitializedFiber;\n  uninitializedFiber.stateNode = root;\n\n  initializeUpdateQueue(uninitializedFiber);\n  // \u8fd9\u4e2aroot\u5c31\u662f\u4e0a\u9762ReactDOMBlockingRoot \u7c7b\u7684 this._internalRoot\n  // \u4e5f\u5c31\u662f\u6700\u4e0afiberRoot\n  return root;\n}",lang:"js"}),r.createElement("h2",{id:"fiberrootnode"},r.createElement(o.AnchorLink,{to:"#fiberrootnode","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"FiberRootNode"),r.createElement(i.Z,{code:"function FiberRootNode(containerInfo, tag, hydrate) {\n  this.tag = tag;\n  this.current = null;\n  this.containerInfo = containerInfo;\n  this.pendingChildren = null;\n  this.pingCache = null;\n  this.finishedExpirationTime = NoWork;\n  this.finishedWork = null;\n  this.timeoutHandle = noTimeout;\n  this.context = null;\n  this.pendingContext = null;\n  this.hydrate = hydrate;\n  this.callbackNode = null;\n  this.callbackPriority = NoPriority;\n  this.firstPendingTime = NoWork;\n  this.lastPendingTime = NoWork;\n  this.firstSuspendedTime = NoWork;\n  this.lastSuspendedTime = NoWork;\n  this.nextKnownPendingLevel = NoWork;\n  this.lastPingedTime = NoWork;\n  this.lastExpiredTime = NoWork;\n  this.mutableSourceLastPendingUpdateTime = NoWork;\n\n  if (enableSchedulerTracing) {\n    this.interactionThreadID = unstable_getThreadID();\n    this.memoizedInteractions = new Set();\n    this.pendingInteractionMap = new Map();\n  }\n  if (enableSuspenseCallback) {\n    this.hydrationCallbacks = null;\n  }\n}",lang:"js"}),r.createElement("p",null,"\u9700\u8981\u6ce8\u610f fiberRoot \u5bf9\u8c61\u548c\u4e0b\u9762\u7684 fiber \u5bf9\u8c61\u533a\u522b\uff0c\u53ef\u4ee5\u7406\u89e3 fiberRoot \u4e3a fiber \u7684\u6839"),r.createElement("h2",{id:"createhostrootfiber"},r.createElement(o.AnchorLink,{to:"#createhostrootfiber","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"createHostRootFiber"),r.createElement(i.Z,{code:"export function createHostRootFiber(tag: RootTag): Fiber {\n  let mode;\n  if (tag === ConcurrentRoot) {\n    mode = ConcurrentMode | BlockingMode | StrictMode;\n  } else if (tag === BlockingRoot) {\n    mode = BlockingMode | StrictMode;\n  } else {\n    mode = NoMode;\n  }\n\n  if (enableProfilerTimer && isDevToolsPresent) {\n    // Always collect profile timings when DevTools are present.\n    // This enables DevTools to start capturing timing at any point\u2013\n    // Without some nodes in the tree having empty base times.\n    mode |= ProfileMode;\n  }\n\n  return createFiber(HostRoot, null, null, mode);\n}",lang:"js"}),r.createElement("h2",{id:"createfiber"},r.createElement(o.AnchorLink,{to:"#createfiber","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"createFiber"),r.createElement(i.Z,{code:"const createFiber = function(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n): Fiber {\n  // $FlowFixMe: the shapes are exact here but Flow doesn't like constructors\n  return new FiberNode(tag, pendingProps, key, mode);\n};",lang:"js"}),r.createElement("h2",{id:"fibernode"},r.createElement(o.AnchorLink,{to:"#fibernode","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"FiberNode"),r.createElement(i.Z,{code:"function FiberNode(\n  tag: WorkTag,\n  pendingProps: mixed,\n  key: null | string,\n  mode: TypeOfMode,\n) {\n  // Instance\n  // \u5b9e\u4f8b\u7684\u7c7b\u578b\uff0c\u51fd\u6570\u7ec4\u4ef6\u3001\u7c7b\u7ec4\u4ef6\u7b49\n  this.tag = tag;\n  this.key = key;\n  this.elementType = null;\n  this.type = null;\n  this.stateNode = null;\n\n  // Fiber\n  this.return = null;\n  this.child = null;\n  this.sibling = null;\n  this.index = 0;\n\n  this.ref = null;\n\n  this.pendingProps = pendingProps;\n  this.memoizedProps = null;\n  this.updateQueue = null;\n  this.memoizedState = null;\n  this.dependencies = null;\n\n  this.mode = mode;\n\n  // Effects\n  this.effectTag = NoEffect;\n  this.nextEffect = null;\n\n  this.firstEffect = null;\n  this.lastEffect = null;\n\n  this.expirationTime = NoWork;\n  this.childExpirationTime = NoWork;\n\n  this.alternate = null;\n\n  if (enableProfilerTimer) {\n    // Note: The following is done to avoid a v8 performance cliff.\n    //\n    // Initializing the fields below to smis and later updating them with\n    // double values will cause Fibers to end up having separate shapes.\n    // This behavior/bug has something to do with Object.preventExtension().\n    // Fortunately this only impacts DEV builds.\n    // Unfortunately it makes React unusably slow for some applications.\n    // To work around this, initialize the fields below with doubles.\n    //\n    // Learn more about this here:\n    // https://github.com/facebook/react/issues/14365\n    // https://bugs.chromium.org/p/v8/issues/detail?id=8538\n    this.actualDuration = Number.NaN;\n    this.actualStartTime = Number.NaN;\n    this.selfBaseDuration = Number.NaN;\n    this.treeBaseDuration = Number.NaN;\n\n    // It's okay to replace the initial doubles with smis after initialization.\n    // This won't trigger the performance cliff mentioned above,\n    // and it simplifies other profiler code (including DevTools).\n    this.actualDuration = 0;\n    this.actualStartTime = -1;\n    this.selfBaseDuration = 0;\n    this.treeBaseDuration = 0;\n  }\n}",lang:"js"}),r.createElement("p",null,"Fiber \u5bf9\u8c61\u7684\u5de5\u5382\uff0c\u5305\u542b fiber \u8282\u70b9\u6240\u6709\u5c5e\u6027"),r.createElement(i.Z,{code:"export function initializeUpdateQueue<State>(fiber: Fiber): void {\n  const queue: UpdateQueue<State> = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: {\n      pending: null,\n    },\n    effects: null,\n  };\n  fiber.updateQueue = queue;\n}",lang:"js"}),r.createElement("p",null,"\u5c31\u662f\u521d\u59cb fiber.updateQueue \u503c\u4e3a\u4e00\u4e2a\u7b80\u5355\u7684\u5bf9\u8c61\u6ca1\u6709\u5565\u7279\u522b\u4e4b\u5904"),r.createElement("h2",{id:"fiberroot-rootfiber-\u5173\u7cfb"},r.createElement(o.AnchorLink,{to:"#fiberroot-rootfiber-\u5173\u7cfb","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"fiberRoot-rootFiber \u5173\u7cfb"),r.createElement("img",{src:"/images/fiberRoot-rootFiber.png"}),r.createElement("p",null,"fiberRoot.current = rootFiber"),r.createElement("p",null,"rootFiber.stateNode = fiberRoot"),r.createElement("p",null,"legacy \u521d\u6b21\u6e32\u67d3"),r.createElement("p",null,"fiberRoot.tag = LegacyRoot = 0"),r.createElement(i.Z,{code:"export type RootTag = 0 | 1 | 2;\nexport const LegacyRoot = 0;\nexport const BlockingRoot = 1;\nexport const ConcurrentRoot = 2;",lang:"js"}),r.createElement("p",null,"rootFiber.tag = HostRoot =0"),r.createElement(i.Z,{code:"// WorkTag\nexport const FunctionComponent = 0;\nexport const ClassComponent = 1;\nexport const IndeterminateComponent = 2; // Before we know whether it is function or class\nexport const HostRoot = 3; // Root of a host tree. Could be nested inside another node.\nexport const HostPortal = 4; // A subtree. Could be an entry point to a different renderer.\nexport const HostComponent = 5;\nexport const HostText = 6;\nexport const Fragment = 7;\nexport const Mode = 8;\nexport const ContextConsumer = 9;\nexport const ContextProvider = 10;\nexport const ForwardRef = 11;\nexport const Profiler = 12;\nexport const SuspenseComponent = 13;\nexport const MemoComponent = 14;\nexport const SimpleMemoComponent = 15;\nexport const LazyComponent = 16;\nexport const IncompleteClassComponent = 17;\nexport const DehydratedFragment = 18;\nexport const SuspenseListComponent = 19;\nexport const FundamentalComponent = 20;\nexport const ScopeComponent = 21;\nexport const Block = 22;",lang:"js"}),r.createElement("h2",{id:"legacycreaterootfromdomcontainer-\u5c0f\u7ed3"},r.createElement(o.AnchorLink,{to:"#legacycreaterootfromdomcontainer-\u5c0f\u7ed3","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"legacyCreateRootFromDOMContainer \u5c0f\u7ed3"),r.createElement("p",null,"\u4ee5\u4e0a\u4e00\u5927\u5806\u4ec5\u4ec5\u662f render \u4e2d legacyCreateRootFromDOMContainer \u90e8\u5206\uff0c\u4e3b\u8981\u4f5c\u7528"),r.createElement("ul",null,r.createElement("li",null,"\u521b\u5efa fiberRoot"),r.createElement("li",null,"\u521b\u5efa rootFiber"),r.createElement("li",null,"\u521d\u59cb\u5316 rootFiber.updateQueue")),r.createElement("h2",{id:"createroot-\u5927\u6982\u8c03\u7528\u6808"},r.createElement(o.AnchorLink,{to:"#createroot-\u5927\u6982\u8c03\u7528\u6808","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"createRoot \u5927\u6982\u8c03\u7528\u6808"),r.createElement("img",{src:"/images/react-legacy-render\u8c03\u7528\u6808.png"}),r.createElement("hr",null),r.createElement("p",null,"\u521b\u5efa\u5b8c fiber \u540e\uff0c\u4e0b\u9762\u521b\u5efa\u66f4\u65b0\uff0c\u8fdb\u5165\u4efb\u52a1\u8c03\u5ea6"),r.createElement("h2",{id:"updatecontainer"},r.createElement(o.AnchorLink,{to:"#updatecontainer","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"updateContainer"),r.createElement(i.Z,{code:'export function updateContainer(\n  element: ReactNodeList,\n  container: OpaqueRoot,\n  parentComponent: ?React$Component<any, any>,\n  callback: ?Function,\n): ExpirationTime {\n  // current = rootFiber.current = rootFiber\n  const current = container.current;\n  const currentTime = requestCurrentTimeForUpdate();\n  // suspense\u76f8\u5173\u7684\u5148\u4e0d\u5173\u6ce8\n  const suspenseConfig = requestCurrentSuspenseConfig();\n  // \u8fc7\u671f\u65e5\u671f\u8fd9\u4e2a\u9700\u8981\u548c\u540e\u9762\u4e32\u8d77\u6765\u770b\n  // legacyRender\u521d\u6b21\u6e32\u67d3\u8fd4\u56de\u4e00\u4e2a\u5e38\u91cfSync = 1073741823\n  const expirationTime = computeExpirationForFiber(\n    currentTime,\n    current,\n    suspenseConfig,\n  );\n\n  const context = getContextForSubtree(parentComponent);\n  if (container.context === null) {\n    container.context = context;\n  } else {\n    container.pendingContext = context;\n  }\n\n  // \u521b\u5efa\u4e00\u4e2a\u66f4\u65b0\uff0c\u5c31\u662f\u4e00\u4e2a\u666e\u901a\u5bf9\u8c61\n  const update = createUpdate(expirationTime, suspenseConfig);\n  // Caution: React DevTools currently depends on this property\n  // being called "element".\n\n  // \u628a<App /> React Element\u4fdd\u5b58\u5230\u66f4\u65b0\u5bf9\u8c61\u4e0a\uff0c\u5728\u4e0b\u9762processUpdateQueue\u4e2d\u4f1a\u4f7f\u7528\n  update.payload = { element };\n\n  callback = callback === undefined ? null : callback;\n  if (callback !== null) {\n    update.callback = callback;\n  }\n\n  enqueueUpdate(current, update);\n  // \u8c03\u5ea6\u4efb\u52a1\n  scheduleUpdateOnFiber(current, expirationTime);\n\n  return expirationTime;\n}',lang:"js"}),r.createElement("h2",{id:"scheduleupdateonfiber"},r.createElement(o.AnchorLink,{to:"#scheduleupdateonfiber","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"scheduleUpdateOnFiber"),r.createElement("p",null,"fiber \u662f fiberRoot.current = rootFiber,\u8fd9\u4e2a\u65f6\u5019\u7684 rootFiber \u8fd8\u662f\u5149\u6807\u53f8\u4ee4,\u5373 child = null \u8fd8\u6ca1\u751f\u6210 fiber \u6811"),r.createElement(i.Z,{code:"export function scheduleUpdateOnFiber(\n  fiber: Fiber,\n  expirationTime: ExpirationTime,\n) {\n  // \u68c0\u67e5\u5d4c\u5957\u66f4\u65b0\u8fbe\u5230\u4e0a\u9650\u62a5\u9519\uff0c\u6bd4\u5982\u5728render\u4e2dsetState\u8fd9\u79cd\u65e0\u9650\u5faa\u73af\n  checkForNestedUpdates();\n  warnAboutRenderPhaseUpdatesInDEV(fiber);\n\n  const root = markUpdateTimeFromFiberToRoot(fiber, expirationTime);\n  if (root === null) {\n    warnAboutUpdateOnUnmountedFiberInDEV(fiber);\n    return;\n  }\n\n  // TODO: computeExpirationForFiber also reads the priority. Pass the\n  // priority as an argument to that function and this one.\n  const priorityLevel = getCurrentPriorityLevel();\n\n  // legacy\u6807\u8bc6\u4e3aSync\n  if (expirationTime === Sync) {\n    // \u786e\u8ba4\u521d\u6b21\u6e32\u67d3\n    if (\n      // Check if we're inside unbatchedUpdates\n      (executionContext & LegacyUnbatchedContext) !== NoContext &&\n      // Check if we're not already rendering\n      (executionContext & (RenderContext | CommitContext)) === NoContext\n    ) {\n      // Register pending interactions on the root to avoid losing traced interaction data.\n      // \u8fd8\u6ca1\u7406\u89e3\u5230\u5e72\u5565\u7684\n\n      schedulePendingInteractions(root, expirationTime);\n\n      // This is a legacy edge case. The initial mount of a ReactDOM.render-ed\n      // root inside of batchedUpdates should be synchronous, but layout updates\n      // should be deferred until the end of the batch.\n      performSyncWorkOnRoot(root);\n    } else {\n      ensureRootIsScheduled(root);\n      schedulePendingInteractions(root, expirationTime);\n      if (executionContext === NoContext) {\n        // Flush the synchronous work now, unless we're already working or inside\n        // a batch. This is intentionally inside scheduleUpdateOnFiber instead of\n        // scheduleCallbackForFiber to preserve the ability to schedule a callback\n        // without immediately flushing it. We only do this for user-initiated\n        // updates, to preserve historical behavior of legacy mode.\n        flushSyncCallbackQueue();\n      }\n    }\n  } else {\n    ensureRootIsScheduled(root);\n    schedulePendingInteractions(root, expirationTime);\n  }\n\n  if (\n    (executionContext & DiscreteEventContext) !== NoContext &&\n    // Only updates at user-blocking priority or greater are considered\n    // discrete, even inside a discrete event.\n    (priorityLevel === UserBlockingPriority ||\n      priorityLevel === ImmediatePriority)\n  ) {\n    // This is the result of a discrete event. Track the lowest priority\n    // discrete update per root so we can flush them early, if needed.\n    if (rootsWithPendingDiscreteUpdates === null) {\n      rootsWithPendingDiscreteUpdates = new Map([[root, expirationTime]]);\n    } else {\n      const lastDiscreteTime = rootsWithPendingDiscreteUpdates.get(root);\n      if (lastDiscreteTime === undefined || lastDiscreteTime > expirationTime) {\n        rootsWithPendingDiscreteUpdates.set(root, expirationTime);\n      }\n    }\n  }\n}",lang:"js"}),r.createElement("h2",{id:"markupdatetimefromfibertoroot"},r.createElement(o.AnchorLink,{to:"#markupdatetimefromfibertoroot","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"markUpdateTimeFromFiberToRoot"),r.createElement(i.Z,{code:"// This is split into a separate function so we can mark a fiber with pending\n// work without treating it as a typical update that originates from an event;\n// e.g. retrying a Suspense boundary isn't an update, but it does schedule work\n// on a fiber.\nfunction markUpdateTimeFromFiberToRoot(fiber, expirationTime) {\n  // Update the source fiber's expiration time\n  // \u8fd9\u4e2afiber\u5c31\u662f\u4e0a\u9762\u901a\u8fc7FiberNode\u5de5\u5382\u521b\u5efa\u7684\uff0cexpirationTime = NoWork = 0\n  // \u4f20\u5165\u7684expirationTime\u662fSync\n  if (fiber.expirationTime < expirationTime) {\n    fiber.expirationTime = expirationTime;\n  }\n  let alternate = fiber.alternate;\n  if (alternate !== null && alternate.expirationTime < expirationTime) {\n    alternate.expirationTime = expirationTime;\n  }\n  // Walk the parent path to the root and update the child expiration time.\n  // \u521d\u6b21\u6e32\u67d3return\u4e3a\u7a7a\u6ca1\u6709\u7236\u7ea7\u8282\u70b9\u4e86\n  let node = fiber.return;\n  let root = null;\n  if (node === null && fiber.tag === HostRoot) {\n    root = fiber.stateNode;\n  } else {\n    // \u975e\u521d\u6b21\u6e32\u67d3\u4ece\u5f53\u524d\u8282\u70b9\u5f80\u4e0a\u5faa\u73af\u8bbe\u7f6e\u6240\u6709\u7236\u8282\u70b9\u7684childExpirationTime = expirationTime\n    // \u6700\u7ec8\u627e\u5230root\n    while (node !== null) {\n      alternate = node.alternate;\n      if (node.childExpirationTime < expirationTime) {\n        node.childExpirationTime = expirationTime;\n        if (\n          alternate !== null &&\n          alternate.childExpirationTime < expirationTime\n        ) {\n          alternate.childExpirationTime = expirationTime;\n        }\n      } else if (\n        alternate !== null &&\n        alternate.childExpirationTime < expirationTime\n      ) {\n        alternate.childExpirationTime = expirationTime;\n      }\n      if (node.return === null && node.tag === HostRoot) {\n        root = node.stateNode;\n        break;\n      }\n      node = node.return;\n    }\n  }\n\n  if (root !== null) {\n    if (workInProgressRoot === root) {\n      // Received an update to a tree that's in the middle of rendering. Mark\n      // that's unprocessed work on this root.\n      markUnprocessedUpdateTime(expirationTime);\n\n      if (workInProgressRootExitStatus === RootSuspendedWithDelay) {\n        // The root already suspended with a delay, which means this render\n        // definitely won't finish. Since we have a new update, let's mark it as\n        // suspended now, right before marking the incoming update. This has the\n        // effect of interrupting the current render and switching to the update.\n        // TODO: This happens to work when receiving an update during the render\n        // phase, because of the trick inside computeExpirationForFiber to\n        // subtract 1 from `renderExpirationTime` to move it into a\n        // separate bucket. But we should probably model it with an exception,\n        // using the same mechanism we use to force hydration of a subtree.\n        // TODO: This does not account for low pri updates that were already\n        // scheduled before the root started rendering. Need to track the next\n        // pending expiration time (perhaps by backtracking the return path) and\n        // then trigger a restart in the `renderDidSuspendDelayIfPossible` path.\n        markRootSuspendedAtTime(root, renderExpirationTime);\n      }\n    }\n    // Mark that the root has a pending update.\n    markRootUpdatedAtTime(root, expirationTime);\n  }\n\n  return root;\n}",lang:"js"}),r.createElement("h2",{id:"performsyncworkonroot"},r.createElement(o.AnchorLink,{to:"#performsyncworkonroot","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"performSyncWorkOnRoot"),r.createElement(i.Z,{code:"// This is the entry point for synchronous tasks that don't go\n// through Scheduler\nfunction performSyncWorkOnRoot(root) {\n  invariant(\n    (executionContext & (RenderContext | CommitContext)) === NoContext,\n    'Should not already be working.',\n  );\n\n  flushPassiveEffects();\n\n  const lastExpiredTime = root.lastExpiredTime;\n\n  let expirationTime;\n  if (lastExpiredTime !== NoWork) {\n    // There's expired work on this root. Check if we have a partial tree\n    // that we can reuse.\n    if (\n      root === workInProgressRoot &&\n      renderExpirationTime >= lastExpiredTime\n    ) {\n      // There's a partial tree with equal or greater than priority than the\n      // expired level. Finish rendering it before rendering the rest of the\n      // expired work.\n      expirationTime = renderExpirationTime;\n    } else {\n      // Start a fresh tree.\n      expirationTime = lastExpiredTime;\n    }\n  } else {\n    // There's no expired work. This must be a new, synchronous render.\n    expirationTime = Sync;\n  }\n\n  let exitStatus = renderRootSync(root, expirationTime);\n\n  if (root.tag !== LegacyRoot && exitStatus === RootErrored) {\n    // If something threw an error, try rendering one more time. We'll\n    // render synchronously to block concurrent data mutations, and we'll\n    // render at Idle (or lower) so that all pending updates are included.\n    // If it still fails after the second attempt, we'll give up and commit\n    // the resulting tree.\n    expirationTime = expirationTime > Idle ? Idle : expirationTime;\n    exitStatus = renderRootSync(root, expirationTime);\n  }\n\n  if (exitStatus === RootFatalErrored) {\n    const fatalError = workInProgressRootFatalError;\n    prepareFreshStack(root, expirationTime);\n    markRootSuspendedAtTime(root, expirationTime);\n    ensureRootIsScheduled(root);\n    throw fatalError;\n  }\n\n  // We now have a consistent tree. Because this is a sync render, we\n  // will commit it even if something suspended.\n  const finishedWork: Fiber = (root.current.alternate: any);\n  root.finishedWork = finishedWork;\n  root.finishedExpirationTime = expirationTime;\n  root.nextKnownPendingLevel = getRemainingExpirationTime(finishedWork);\n  commitRoot(root);\n\n  // Before exiting, make sure there's a callback scheduled for the next\n  // pending level.\n  ensureRootIsScheduled(root);\n\n  return null;\n}",lang:"js"}),r.createElement("h2",{id:"renderrootsync"},r.createElement(o.AnchorLink,{to:"#renderrootsync","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"renderRootSync"),r.createElement(i.Z,{code:"function renderRootSync(root, expirationTime) {\n  const prevExecutionContext = executionContext;\n  executionContext |= RenderContext;\n  // \u83b7\u53d6\u5230\u8c03\u5ea6\u5668\uff0chook\u9996\u6b21\u6e32\u67d3\u548c\u66f4\u65b0\u8ddf\u8fd9\u4e2a\u4e5f\u6709\u5173\u7cfb\n  const prevDispatcher = pushDispatcher(root);\n\n  // If the root or expiration time have changed, throw out the existing stack\n  // and prepare a fresh one. Otherwise we'll continue where we left off.\n  // \u5f53\u524d\u8981\u66f4\u65b0\u7684\u8282\u70b9\u4e0d\u662f\u8fdb\u7a0b\u4e2d\u7684\u8282\u70b9\uff0c\u8bc1\u660e\u66f4\u65b0\u88ab\u6253\u65ad\u6216\u8005\u8bf4\u662f\u521d\u6b21\u6e32\u67d3workInProgressRoot\u8fd8\u6ca1\u521b\u5efa\uff0c\u9700\u8981\u91cd\u65b0\u521d\u59cb\u5316\n  // \u8fd9\u91cc\u5e94\u8be5\u8981\u548c\u5e76\u53d1\u66f4\u65b0\u4e00\u8d77\u770b\n  // \u521d\u6b21\u6e32\u67d3\u8fd9\u91cc\u7406\u89e3\u4e3aworkInProgressRoot\u8fd8\u662f\u7a7a\u7684\n  if (root !== workInProgressRoot || expirationTime !== renderExpirationTime) {\n    // \u51c6\u5907\u65b0\u7684\u5806\u6808\uff0c\u5176\u5b9e\u5c31\u662f\u521b\u5efaworkInProgress\n    prepareFreshStack(root, expirationTime);\n    // \u770b\u4e0d\u61c2\uff0c\u8df3\u8fc7\n    startWorkOnPendingInteractions(root, expirationTime);\n  }\n\n  const prevInteractions = pushInteractions(root);\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      const priorityLevel = getCurrentPriorityLevel();\n      const label = priorityLevelToLabel(priorityLevel);\n      logRenderStarted(label);\n    }\n  }\n\n  do {\n    try {\n      workLoopSync();\n      break;\n    } catch (thrownValue) {\n      handleError(root, thrownValue);\n    }\n  } while (true);\n  resetContextDependencies();\n  if (enableSchedulerTracing) {\n    popInteractions(((prevInteractions: any): Set<Interaction>));\n  }\n\n  executionContext = prevExecutionContext;\n  popDispatcher(prevDispatcher);\n\n  if (workInProgress !== null) {\n    // This is a sync render, so we should have finished the whole tree.\n    invariant(\n      false,\n      'Cannot commit an incomplete root. This error is likely caused by a ' +\n        'bug in React. Please file an issue.',\n    );\n  }\n\n  if (__DEV__) {\n    if (enableDebugTracing) {\n      logRenderStopped();\n    }\n  }\n\n  // Set this to null to indicate there's no in-progress render.\n  workInProgressRoot = null;\n\n  return workInProgressRootExitStatus;\n}",lang:"js"}),r.createElement("h2",{id:"preparefreshstack"},r.createElement(o.AnchorLink,{to:"#preparefreshstack","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"prepareFreshStack"),r.createElement("p",null,"\u521d\u6b21\u6e32\u67d3\u53ef\u4ee5\u7406\u89e3\u4e3a\u521d\u59cb\u5316 workInProgress"),r.createElement(i.Z,{code:"function prepareFreshStack(root, expirationTime) {\n  root.finishedWork = null;\n  root.finishedExpirationTime = NoWork;\n\n  const timeoutHandle = root.timeoutHandle;\n  if (timeoutHandle !== noTimeout) {\n    // The root previous suspended and scheduled a timeout to commit a fallback\n    // state. Now that we have additional work, cancel the timeout.\n    root.timeoutHandle = noTimeout;\n    // $FlowFixMe Complains noTimeout is not a TimeoutID, despite the check above\n    cancelTimeout(timeoutHandle);\n  }\n\n  // Check if there's a suspended level at lower priority.\n  const lastSuspendedTime = root.lastSuspendedTime;\n  if (lastSuspendedTime !== NoWork && lastSuspendedTime < expirationTime) {\n    const lastPingedTime = root.lastPingedTime;\n    // Make sure the suspended level is marked as pinged so that we return back\n    // to it later, in case the render we're about to start gets aborted.\n    // Generally we only reach this path via a ping, but we shouldn't assume\n    // that will always be the case.\n    // Note: This is defensive coding to prevent a pending commit from\n    // being dropped without being rescheduled. It shouldn't be necessary.\n    if (lastPingedTime === NoWork || lastPingedTime > lastSuspendedTime) {\n      root.lastPingedTime = lastSuspendedTime;\n    }\n  }\n\n  if (workInProgress !== null) {\n    let interruptedWork = workInProgress.return;\n    while (interruptedWork !== null) {\n      unwindInterruptedWork(interruptedWork);\n      interruptedWork = interruptedWork.return;\n    }\n  }\n  workInProgressRoot = root;\n  workInProgress = createWorkInProgress(root.current, null);\n  renderExpirationTime = expirationTime;\n  workInProgressRootExitStatus = RootIncomplete;\n  workInProgressRootFatalError = null;\n  workInProgressRootLatestProcessedExpirationTime = Sync;\n  workInProgressRootLatestSuspenseTimeout = Sync;\n  workInProgressRootCanSuspendUsingConfig = null;\n  workInProgressRootNextUnprocessedUpdateTime = NoWork;\n  workInProgressRootHasPendingPing = false;\n\n  if (enableSchedulerTracing) {\n    spawnedWorkDuringRender = null;\n  }\n\n  if (__DEV__) {\n    ReactStrictModeWarnings.discardPendingWarnings();\n  }\n}",lang:"js"}),r.createElement("h2",{id:"createworkinprogress"},r.createElement(o.AnchorLink,{to:"#createworkinprogress","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"createWorkInProgress"),r.createElement("p",null,"\u521b\u5efa workInProgress\uff0c\u4e14\u628a fiber.alternate \u6307\u5411\u8be5 workInProgress\uff0c\u8868\u793a fiber \u5c06\u8981\u4f7f\u7528 alternate\uff08workInProgress\uff09 \u66f4\u65b0"),r.createElement("p",null,"current.alternate = workInProgress"),r.createElement("p",null,"workInProgress.alternate = current"),r.createElement("p",null,"workInProgress.stateNode = current.stateNode"),r.createElement("p",null,"\u53e6\u5916 workInProgress \u590d\u7528\u5927\u91cf current \u4e0a\u7684\u5c5e\u6027"),r.createElement(i.Z,{code:"// This is used to create an alternate fiber to do work on.\nexport function createWorkInProgress(current: Fiber, pendingProps: any): Fiber {\n  let workInProgress = current.alternate;\n  if (workInProgress === null) {\n    // We use a double buffering pooling technique because we know that we'll\n    // only ever need at most two versions of a tree. We pool the \"other\" unused\n    // node that we're free to reuse. This is lazily created to avoid allocating\n    // extra objects for things that are never updated. It also allow us to\n    // reclaim the extra memory if needed.\n\n    // workInProgress\u5176\u5b9e\u5c31\u662ffiber\u5bf9\u8c61\n    workInProgress = createFiber(\n      current.tag,\n      pendingProps,\n      current.key,\n      current.mode,\n    );\n    workInProgress.elementType = current.elementType;\n    workInProgress.type = current.type;\n    workInProgress.stateNode = current.stateNode;\n\n    workInProgress.alternate = current;\n    current.alternate = workInProgress;\n  } else {\n    workInProgress.pendingProps = pendingProps;\n\n    // We already have an alternate.\n    // Reset the effect tag.\n    workInProgress.effectTag = NoEffect;\n\n    // The effect list is no longer valid.\n    workInProgress.nextEffect = null;\n    workInProgress.firstEffect = null;\n    workInProgress.lastEffect = null;\n\n    if (enableProfilerTimer) {\n      // We intentionally reset, rather than copy, actualDuration & actualStartTime.\n      // This prevents time from endlessly accumulating in new commits.\n      // This has the downside of resetting values for different priority renders,\n      // But works for yielding (the common case) and should support resuming.\n      workInProgress.actualDuration = 0;\n      workInProgress.actualStartTime = -1;\n    }\n  }\n\n  if (throwEarlyForMysteriousError) {\n    // Trying to debug a mysterious internal-only production failure.\n    // See D20130868 and t62461245.\n    // This is only on for RN FB builds.\n    if (current == null) {\n      throw Error('current is ' + current + \" but it can't be\");\n    }\n    if (workInProgress == null) {\n      throw Error('workInProgress is ' + workInProgress + \" but it can't be\");\n    }\n  }\n\n  workInProgress.childExpirationTime = current.childExpirationTime;\n  workInProgress.expirationTime = current.expirationTime;\n\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n\n  // Clone the dependencies object. This is mutated during the render phase, so\n  // it cannot be shared with the current fiber.\n  const currentDependencies = current.dependencies;\n  workInProgress.dependencies =\n    currentDependencies === null\n      ? null\n      : {\n          expirationTime: currentDependencies.expirationTime,\n          firstContext: currentDependencies.firstContext,\n          responders: currentDependencies.responders,\n        };\n\n  // These will be overridden during the parent's reconciliation\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n\n  if (enableProfilerTimer) {\n    workInProgress.selfBaseDuration = current.selfBaseDuration;\n    workInProgress.treeBaseDuration = current.treeBaseDuration;\n  }\n\n  return workInProgress;\n}",lang:"js"}),r.createElement(i.Z,{code:"// The work loop is an extremely hot path. Tell Closure not to inline it.\n/** @noinline */\nfunction workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}",lang:"js"}),r.createElement(i.Z,{code:"function performUnitOfWork(unitOfWork: Fiber): void {\n  // The current, flushed, state of this fiber is the alternate. Ideally\n  // nothing should rely on this, but relying on it here means that we don't\n  // need an additional field on the work in progress.\n  const current = unitOfWork.alternate;\n  setCurrentDebugFiberInDEV(unitOfWork);\n\n  let next;\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    startProfilerTimer(unitOfWork);\n    // \u9996\u6b21next\u4e3a\u65b0\u751f\u6210\u7684<App/>fiber\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n    stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);\n  } else {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  resetCurrentDebugFiberInDEV();\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    // If this doesn't spawn new work, complete the current work.\n    completeUnitOfWork(unitOfWork);\n  } else {\n    // \u91cd\u65b0\u8d4b\u503c\u8fdb\u5165\u4e0b\u4e00\u8f6e\uff0c\n    // \u518d\u6b21\u8fdb\u5165performUnitOfWork(next)\n    // \u76f4\u5230workInProgress\u4e3a\u7a7a\u5b8c\u6210\uff0c\u5b8c\u6210\u6574\u4e2afiber\u6811\u521b\u5efa\n    workInProgress = next;\n  }\n\n  ReactCurrentOwner.current = null;\n}",lang:"js"}),r.createElement("h2",{id:"beginwork"},r.createElement(o.AnchorLink,{to:"#beginwork","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"beginWork"),r.createElement("p",null,"\u5230\u8fd9\u91cc current \u8fd8\u662f rootFiber"),r.createElement(i.Z,{code:"function beginWork(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  renderExpirationTime: ExpirationTime,\n): Fiber | null {\n  const updateExpirationTime = workInProgress.expirationTime;\n\n  if (current !== null) {\n    const oldProps = current.memoizedProps;\n    const newProps = workInProgress.pendingProps;\n\n    if (\n      oldProps !== newProps ||\n      hasLegacyContextChanged() ||\n      // Force a re-render if the implementation changed due to hot reload:\n      (__DEV__ ? workInProgress.type !== current.type : false)\n    ) {\n      // If props or context changed, mark the fiber as having performed work.\n      // This may be unset if the props are determined to be equal later (memo).\n      didReceiveUpdate = true;\n    } else if (updateExpirationTime < renderExpirationTime) {\n      didReceiveUpdate = false;\n      // This fiber does not have any pending work. Bailout without entering\n      // the begin phase. There's still some bookkeeping we that needs to be done\n      // in this optimized path, mostly pushing stuff onto the stack.\n      switch (workInProgress.tag) {\n        case HostRoot:\n          pushHostRootContext(workInProgress);\n          resetHydrationState();\n          break;\n        case HostComponent:\n          pushHostContext(workInProgress);\n          if (\n            workInProgress.mode & ConcurrentMode &&\n            renderExpirationTime !== Never &&\n            shouldDeprioritizeSubtree(workInProgress.type, newProps)\n          ) {\n            if (enableSchedulerTracing) {\n              markSpawnedWork(Never);\n            }\n            // Schedule this fiber to re-render at offscreen priority. Then bailout.\n            workInProgress.expirationTime = workInProgress.childExpirationTime = Never;\n            return null;\n          }\n          break;\n        case ClassComponent: {\n          const Component = workInProgress.type;\n          if (isLegacyContextProvider(Component)) {\n            pushLegacyContextProvider(workInProgress);\n          }\n          break;\n        }\n        case HostPortal:\n          pushHostContainer(\n            workInProgress,\n            workInProgress.stateNode.containerInfo,\n          );\n          break;\n        case ContextProvider: {\n          const newValue = workInProgress.memoizedProps.value;\n          pushProvider(workInProgress, newValue);\n          break;\n        }\n        case Profiler:\n          if (enableProfilerTimer) {\n            // Profiler should only call onRender when one of its descendants actually rendered.\n            const hasChildWork =\n              workInProgress.childExpirationTime >= renderExpirationTime;\n            if (hasChildWork) {\n              workInProgress.effectTag |= Update;\n            }\n\n            // Reset effect durations for the next eventual effect phase.\n            // These are reset during render to allow the DevTools commit hook a chance to read them,\n            const stateNode = workInProgress.stateNode;\n            stateNode.effectDuration = 0;\n            stateNode.passiveEffectDuration = 0;\n          }\n          break;\n        case SuspenseComponent: {\n          const state: SuspenseState | null = workInProgress.memoizedState;\n          if (state !== null) {\n            if (enableSuspenseServerRenderer) {\n              if (state.dehydrated !== null) {\n                pushSuspenseContext(\n                  workInProgress,\n                  setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n                );\n                // We know that this component will suspend again because if it has\n                // been unsuspended it has committed as a resolved Suspense component.\n                // If it needs to be retried, it should have work scheduled on it.\n                workInProgress.effectTag |= DidCapture;\n                break;\n              }\n            }\n\n            // If this boundary is currently timed out, we need to decide\n            // whether to retry the primary children, or to skip over it and\n            // go straight to the fallback. Check the priority of the primary\n            // child fragment.\n            const primaryChildFragment: Fiber = (workInProgress.child: any);\n            const primaryChildExpirationTime =\n              primaryChildFragment.childExpirationTime;\n            if (primaryChildExpirationTime >= renderExpirationTime) {\n              // The primary children have pending work. Use the normal path\n              // to attempt to render the primary children again.\n              return updateSuspenseComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            } else {\n              // The primary child fragment does not have pending work marked\n              // on it...\n\n              // ...usually. There's an unfortunate edge case where the fragment\n              // fiber is not part of the return path of the children, so when\n              // an update happens, the fragment doesn't get marked during\n              // setState. This is something we should consider addressing when\n              // we refactor the Fiber data structure. (There's a test with more\n              // details; to find it, comment out the following block and see\n              // which one fails.)\n              //\n              // As a workaround, we need to recompute the `childExpirationTime`\n              // by bubbling it up from the next level of children. This is\n              // based on similar logic in `resetChildExpirationTime`.\n              let primaryChild = primaryChildFragment.child;\n              while (primaryChild !== null) {\n                const childUpdateExpirationTime = primaryChild.expirationTime;\n                const childChildExpirationTime =\n                  primaryChild.childExpirationTime;\n                if (\n                  childUpdateExpirationTime >= renderExpirationTime ||\n                  childChildExpirationTime >= renderExpirationTime\n                ) {\n                  // Found a child with an update with sufficient priority.\n                  // Use the normal path to render the primary children again.\n                  return updateSuspenseComponent(\n                    current,\n                    workInProgress,\n                    renderExpirationTime,\n                  );\n                }\n                primaryChild = primaryChild.sibling;\n              }\n\n              pushSuspenseContext(\n                workInProgress,\n                setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n              );\n              // The primary children do not have pending work with sufficient\n              // priority. Bailout.\n              const child = bailoutOnAlreadyFinishedWork(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n              if (child !== null) {\n                // The fallback children have pending work. Skip over the\n                // primary children and work on the fallback.\n                return child.sibling;\n              } else {\n                return null;\n              }\n            }\n          } else {\n            pushSuspenseContext(\n              workInProgress,\n              setDefaultShallowSuspenseContext(suspenseStackCursor.current),\n            );\n          }\n          break;\n        }\n        case SuspenseListComponent: {\n          const didSuspendBefore =\n            (current.effectTag & DidCapture) !== NoEffect;\n\n          const hasChildWork =\n            workInProgress.childExpirationTime >= renderExpirationTime;\n\n          if (didSuspendBefore) {\n            if (hasChildWork) {\n              // If something was in fallback state last time, and we have all the\n              // same children then we're still in progressive loading state.\n              // Something might get unblocked by state updates or retries in the\n              // tree which will affect the tail. So we need to use the normal\n              // path to compute the correct tail.\n              return updateSuspenseListComponent(\n                current,\n                workInProgress,\n                renderExpirationTime,\n              );\n            }\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            workInProgress.effectTag |= DidCapture;\n          }\n\n          // If nothing suspended before and we're rendering the same children,\n          // then the tail doesn't matter. Anything new that suspends will work\n          // in the \"together\" mode, so we can continue from the state we had.\n          const renderState = workInProgress.memoizedState;\n          if (renderState !== null) {\n            // Reset to the \"together\" mode in case we've started a different\n            // update in the past but didn't complete it.\n            renderState.rendering = null;\n            renderState.tail = null;\n            renderState.lastEffect = null;\n          }\n          pushSuspenseContext(workInProgress, suspenseStackCursor.current);\n\n          if (hasChildWork) {\n            break;\n          } else {\n            // If none of the children had any work, that means that none of\n            // them got retried so they'll still be blocked in the same way\n            // as before. We can fast bail out.\n            return null;\n          }\n        }\n      }\n      return bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    } else {\n      // An update was scheduled on this fiber, but there are no new props\n      // nor legacy context. Set this to false. If an update queue or context\n      // consumer produces a changed value, it will set this to true. Otherwise,\n      // the component will assume the children have not changed and bail out.\n\n      // \u521d\u6b21\u6e32\u67d3\u6807\u8bb0\u4e0d\u9700\u8981\u66f4\u65b0\uff0c\u76f4\u63a5\u8df3\u8fc7\n      didReceiveUpdate = false;\n    }\n  } else {\n    didReceiveUpdate = false;\n  }\n\n  // Before entering the begin phase, clear pending update priority.\n  // TODO: This assumes that we're about to evaluate the component and process\n  // the update queue. However, there's an exception: SimpleMemoComponent\n  // sometimes bails out later in the begin phase. This indicates that we should\n  // move this assignment out of the common path and into each branch.\n  workInProgress.expirationTime = NoWork;\n\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n      return mountIndeterminateComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        renderExpirationTime,\n      );\n    }\n    case LazyComponent: {\n      const elementType = workInProgress.elementType;\n      return mountLazyComponent(\n        current,\n        workInProgress,\n        elementType,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case FunctionComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case ClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return updateClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    // \u521d\u6b21\u6e32\u67d3rootFiber.tag = HostRoot\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    case HostComponent:\n      return updateHostComponent(current, workInProgress, renderExpirationTime);\n    case HostText:\n      return updateHostText(current, workInProgress);\n    case SuspenseComponent:\n      return updateSuspenseComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case HostPortal:\n      return updatePortalComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ForwardRef: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === type\n          ? unresolvedProps\n          : resolveDefaultProps(type, unresolvedProps);\n      return updateForwardRef(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case Fragment:\n      return updateFragment(current, workInProgress, renderExpirationTime);\n    case Mode:\n      return updateMode(current, workInProgress, renderExpirationTime);\n    case Profiler:\n      return updateProfiler(current, workInProgress, renderExpirationTime);\n    case ContextProvider:\n      return updateContextProvider(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case ContextConsumer:\n      return updateContextConsumer(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    case MemoComponent: {\n      const type = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      // Resolve outer props first, then resolve inner props.\n      let resolvedProps = resolveDefaultProps(type, unresolvedProps);\n      if (__DEV__) {\n        if (workInProgress.type !== workInProgress.elementType) {\n          const outerPropTypes = type.propTypes;\n          if (outerPropTypes) {\n            checkPropTypes(\n              outerPropTypes,\n              resolvedProps, // Resolved for outer only\n              'prop',\n              getComponentName(type),\n            );\n          }\n        }\n      }\n      resolvedProps = resolveDefaultProps(type.type, resolvedProps);\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        type,\n        resolvedProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case SimpleMemoComponent: {\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        updateExpirationTime,\n        renderExpirationTime,\n      );\n    }\n    case IncompleteClassComponent: {\n      const Component = workInProgress.type;\n      const unresolvedProps = workInProgress.pendingProps;\n      const resolvedProps =\n        workInProgress.elementType === Component\n          ? unresolvedProps\n          : resolveDefaultProps(Component, unresolvedProps);\n      return mountIncompleteClassComponent(\n        current,\n        workInProgress,\n        Component,\n        resolvedProps,\n        renderExpirationTime,\n      );\n    }\n    case SuspenseListComponent: {\n      return updateSuspenseListComponent(\n        current,\n        workInProgress,\n        renderExpirationTime,\n      );\n    }\n    case FundamentalComponent: {\n      if (enableFundamentalAPI) {\n        return updateFundamentalComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n    case ScopeComponent: {\n      if (enableScopeAPI) {\n        return updateScopeComponent(\n          current,\n          workInProgress,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n    case Block: {\n      if (enableBlocksAPI) {\n        const block = workInProgress.type;\n        const props = workInProgress.pendingProps;\n        return updateBlock(\n          current,\n          workInProgress,\n          block,\n          props,\n          renderExpirationTime,\n        );\n      }\n      break;\n    }\n  }\n  invariant(\n    false,\n    'Unknown unit of work tag (%s). This error is likely caused by a bug in ' +\n      'React. Please file an issue.',\n    workInProgress.tag,\n  );\n}",lang:"js"}),r.createElement("h2",{id:"updatehostroot"},r.createElement(o.AnchorLink,{to:"#updatehostroot","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"updateHostRoot"),r.createElement(i.Z,{code:"function updateHostRoot(current, workInProgress, renderExpirationTime) {\n  pushHostRootContext(workInProgress);\n  const updateQueue = workInProgress.updateQueue;\n  invariant(\n    current !== null && updateQueue !== null,\n    'If the root does not have an updateQueue, we should have already ' +\n      'bailed out. This error is likely caused by a bug in React. Please ' +\n      'file an issue.',\n  );\n  const nextProps = workInProgress.pendingProps;\n  const prevState = workInProgress.memoizedState;\n  const prevChildren = prevState !== null ? prevState.element : null;\n  cloneUpdateQueue(current, workInProgress);\n  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);\n  const nextState = workInProgress.memoizedState;\n  // Caution: React DevTools currently depends on this property\n  // being called \"element\".\n  const nextChildren = nextState.element;\n  if (nextChildren === prevChildren) {\n    // If the state is the same as before, that's a bailout because we had\n    // no work that expires at this time.\n    resetHydrationState();\n    return bailoutOnAlreadyFinishedWork(\n      current,\n      workInProgress,\n      renderExpirationTime,\n    );\n  }\n  // \u83b7\u53d6fiberRoot\u5224\u65ad\u662f\u5426\u4e3aSSR\uff0c\u5426\u5219\u5f00\u59cb\u5904\u7406<App/>\u5b50\u8282\u70b9\n  const root: FiberRoot = workInProgress.stateNode;\n  if (root.hydrate && enterHydrationState(workInProgress)) {\n    // If we don't have any current children this might be the first pass.\n    // We always try to hydrate. If this isn't a hydration pass there won't\n    // be any children to hydrate which is effectively the same thing as\n    // not hydrating.\n\n    const child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n    workInProgress.child = child;\n\n    let node = child;\n    while (node) {\n      // Mark each child as hydrating. This is a fast path to know whether this\n      // tree is part of a hydrating tree. This is used to determine if a child\n      // node has fully mounted yet, and for scheduling event replaying.\n      // Conceptually this is similar to Placement in that a new subtree is\n      // inserted into the React tree here. It just happens to not need DOM\n      // mutations because it already exists.\n      node.effectTag = (node.effectTag & ~Placement) | Hydrating;\n      node = node.sibling;\n    }\n  } else {\n    // Otherwise reset hydration state in case we aborted and resumed another\n    // root.\n    // \u521d\u6b21\u6e32\u67d3\uff0c\u521b\u5efarootFiber\u7684\u5b50\u8282\u70b9\u5373<App/>\n    reconcileChildren(\n      current,\n      workInProgress,\n      nextChildren,\n      renderExpirationTime,\n    );\n    resetHydrationState();\n  }\n  // \u9996\u6b21\u8fd4\u56de<App/>\u5bf9\u5e94fiber\n  return workInProgress.child;\n}",lang:"js"}),r.createElement("h2",{id:"processupdatequeue"},r.createElement(o.AnchorLink,{to:"#processupdatequeue","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"processUpdateQueue"),r.createElement(i.Z,{code:"export function processUpdateQueue<State>(\n  workInProgress: Fiber,\n  props: any,\n  instance: any,\n  renderExpirationTime: ExpirationTime,\n): void {\n  // This is always non-null on a ClassComponent or HostRoot\n\n  // \u8fd9\u91cc\u7684\u66f4\u65b0\u961f\u5217\u5c31\u662f\u4e0a\u9762updateContainer\u521b\u5efa\u7684\uff0c\u91cc\u9762\u5305\u542bpayload.element = <App/>\u5143\u7d20\n  const queue: UpdateQueue<State> = (workInProgress.updateQueue: any);\n\n  hasForceUpdate = false;\n\n  if (__DEV__) {\n    currentlyProcessingQueue = queue.shared;\n  }\n\n  let firstBaseUpdate = queue.firstBaseUpdate;\n  let lastBaseUpdate = queue.lastBaseUpdate;\n\n  // Check if there are pending updates. If so, transfer them to the base queue.\n  let pendingQueue = queue.shared.pending;\n  if (pendingQueue !== null) {\n    queue.shared.pending = null;\n\n    // The pending queue is circular. Disconnect the pointer between first\n    // and last so that it's non-circular.\n    const lastPendingUpdate = pendingQueue;\n    const firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    // Append pending updates to base queue\n    if (lastBaseUpdate === null) {\n      firstBaseUpdate = firstPendingUpdate;\n    } else {\n      lastBaseUpdate.next = firstPendingUpdate;\n    }\n    lastBaseUpdate = lastPendingUpdate;\n\n    // If there's a current queue, and it's different from the base queue, then\n    // we need to transfer the updates to that queue, too. Because the base\n    // queue is a singly-linked list with no cycles, we can append to both\n    // lists and take advantage of structural sharing.\n    // TODO: Pass `current` as argument\n\n    const current = workInProgress.alternate;\n    if (current !== null) {\n      // This is always non-null on a ClassComponent or HostRoot\n      const currentQueue: UpdateQueue<State> = (current.updateQueue: any);\n      const currentLastBaseUpdate = currentQueue.lastBaseUpdate;\n      if (currentLastBaseUpdate !== lastBaseUpdate) {\n        if (currentLastBaseUpdate === null) {\n          currentQueue.firstBaseUpdate = firstPendingUpdate;\n        } else {\n          currentLastBaseUpdate.next = firstPendingUpdate;\n        }\n        currentQueue.lastBaseUpdate = lastPendingUpdate;\n      }\n    }\n  }\n\n  // These values may change as we process the queue.\n  if (firstBaseUpdate !== null) {\n    // Iterate through the list of updates to compute the result.\n    let newState = queue.baseState;\n    let newExpirationTime = NoWork;\n\n    let newBaseState = null;\n    let newFirstBaseUpdate = null;\n    let newLastBaseUpdate = null;\n\n    let update = firstBaseUpdate;\n    do {\n      const updateExpirationTime = update.expirationTime;\n      if (updateExpirationTime < renderExpirationTime) {\n        // Priority is insufficient. Skip this update. If this is the first\n        // skipped update, the previous update/state is the new base\n        // update/state.\n        const clone: Update<State> = {\n          expirationTime: update.expirationTime,\n          suspenseConfig: update.suspenseConfig,\n\n          tag: update.tag,\n          payload: update.payload,\n          callback: update.callback,\n\n          next: null,\n        };\n        if (newLastBaseUpdate === null) {\n          newFirstBaseUpdate = newLastBaseUpdate = clone;\n          newBaseState = newState;\n        } else {\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n        // Update the remaining priority in the queue.\n        if (updateExpirationTime > newExpirationTime) {\n          newExpirationTime = updateExpirationTime;\n        }\n      } else {\n        // This update does have sufficient priority.\n\n        if (newLastBaseUpdate !== null) {\n          const clone: Update<State> = {\n            expirationTime: Sync, // This update is going to be committed so we never want uncommit it.\n            suspenseConfig: update.suspenseConfig,\n\n            tag: update.tag,\n            payload: update.payload,\n            callback: update.callback,\n\n            next: null,\n          };\n          newLastBaseUpdate = newLastBaseUpdate.next = clone;\n        }\n\n        // Mark the event time of this update as relevant to this render pass.\n        // TODO: This should ideally use the true event time of this update rather than\n        // its priority which is a derived and not reverseable value.\n        // TODO: We should skip this update if it was already committed but currently\n        // we have no way of detecting the difference between a committed and suspended\n        // update here.\n        markRenderEventTimeAndConfig(\n          updateExpirationTime,\n          update.suspenseConfig,\n        );\n\n        // Process this update.\n\n        // \u5f97\u5230{element: <App/>}\n        newState = getStateFromUpdate(\n          workInProgress,\n          queue,\n          update,\n          newState,\n          props,\n          instance,\n        );\n        const callback = update.callback;\n        if (callback !== null) {\n          workInProgress.effectTag |= Callback;\n          const effects = queue.effects;\n          if (effects === null) {\n            queue.effects = [update];\n          } else {\n            effects.push(update);\n          }\n        }\n      }\n      update = update.next;\n      if (update === null) {\n        pendingQueue = queue.shared.pending;\n        // \u521d\u6b21\u6e32\u67d3\u66f4\u65b0\u540e\u9000\u51fa\n        if (pendingQueue === null) {\n          break;\n        } else {\n          // An update was scheduled from inside a reducer. Add the new\n          // pending updates to the end of the list and keep processing.\n          const lastPendingUpdate = pendingQueue;\n          // Intentionally unsound. Pending updates form a circular list, but we\n          // unravel them when transferring them to the base queue.\n          const firstPendingUpdate = ((lastPendingUpdate.next: any): Update<State>);\n          lastPendingUpdate.next = null;\n          update = firstPendingUpdate;\n          queue.lastBaseUpdate = lastPendingUpdate;\n          queue.shared.pending = null;\n        }\n      }\n    } while (true);\n\n    if (newLastBaseUpdate === null) {\n      newBaseState = newState;\n    }\n\n    queue.baseState = ((newBaseState: any): State);\n    queue.firstBaseUpdate = newFirstBaseUpdate;\n    queue.lastBaseUpdate = newLastBaseUpdate;\n\n    // Set the remaining expiration time to be whatever is remaining in the queue.\n    // This should be fine because the only two other things that contribute to\n    // expiration time are props and context. We're already in the middle of the\n    // begin phase by the time we start processing the queue, so we've already\n    // dealt with the props. Context in components that specify\n    // shouldComponentUpdate is tricky; but we'll have to account for\n    // that regardless.\n    markUnprocessedUpdateTime(newExpirationTime);\n    workInProgress.expirationTime = newExpirationTime;\n    workInProgress.memoizedState = newState;\n  }\n\n  if (__DEV__) {\n    currentlyProcessingQueue = null;\n  }\n}",lang:"js"}),r.createElement(i.Z,{code:"export function reconcileChildren(\n  current: Fiber | null,\n  workInProgress: Fiber,\n  nextChildren: any,\n  renderExpirationTime: ExpirationTime,\n) {\n  if (current === null) {\n    // If this is a fresh new component that hasn't been rendered yet, we\n    // won't update its child set by applying minimal side-effects. Instead,\n    // we will add them all to the child before it gets rendered. That means\n    // we can optimize this reconciliation pass by not tracking side-effects.\n    workInProgress.child = mountChildFibers(\n      workInProgress,\n      null,\n      nextChildren,\n      renderExpirationTime,\n    );\n  } else {\n    // If the current child is the same as the work in progress, it means that\n    // we haven't yet started any work on these children. Therefore, we use\n    // the clone algorithm to create a copy of all the current children.\n\n    // If we had any progressed work already, that is invalid at this point so\n    // let's throw it out.\n\n    // \u7ec8\u4e8e\u5230\u751f\u6210fiberTree\u4e86\n    // \u9996\u6b21\u751f\u6210<App/>\u5bf9\u5e94\u7684fiber\n    workInProgress.child = reconcileChildFibers(\n      workInProgress,\n      current.child,\n      nextChildren,\n      renderExpirationTime,\n    );\n  }\n}",lang:"js"}),r.createElement("h2",{id:"reconcilechildfibers"},r.createElement(o.AnchorLink,{to:"#reconcilechildfibers","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"reconcileChildFibers"),r.createElement(i.Z,{code:"// This API will tag the children with the side-effect of the reconciliation\n// itself. They will be added to the side-effect list as we pass through the\n// children and the parent.\nfunction reconcileChildFibers(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  newChild: any,\n  expirationTime: ExpirationTime,\n): Fiber | null {\n  // This function is not recursive.\n  // If the top level item is an array, we treat it as a set of children,\n  // not as a fragment. Nested arrays on the other hand will be treated as\n  // fragment nodes. Recursion happens at the normal flow.\n\n  // Handle top level unkeyed fragments as if they were arrays.\n  // This leads to an ambiguity between <>{[...]}</> and <>...</>.\n  // We treat the ambiguous cases above the same.\n  const isUnkeyedTopLevelFragment =\n    typeof newChild === 'object' &&\n    newChild !== null &&\n    newChild.type === REACT_FRAGMENT_TYPE &&\n    newChild.key === null;\n  if (isUnkeyedTopLevelFragment) {\n    newChild = newChild.props.children;\n  }\n\n  // Handle object types\n  const isObject = typeof newChild === 'object' && newChild !== null;\n\n  if (isObject) {\n    switch (newChild.$$typeof) {\n      case REACT_ELEMENT_TYPE:\n        return placeSingleChild(\n          // \u751f\u6210App element\u7684fiber\u6570\u636e\n          reconcileSingleElement(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n      case REACT_PORTAL_TYPE:\n        return placeSingleChild(\n          reconcileSinglePortal(\n            returnFiber,\n            currentFirstChild,\n            newChild,\n            expirationTime,\n          ),\n        );\n    }\n  }\n\n  if (typeof newChild === 'string' || typeof newChild === 'number') {\n    return placeSingleChild(\n      reconcileSingleTextNode(\n        returnFiber,\n        currentFirstChild,\n        '' + newChild,\n        expirationTime,\n      ),\n    );\n  }\n\n  if (isArray(newChild)) {\n    return reconcileChildrenArray(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  if (getIteratorFn(newChild)) {\n    return reconcileChildrenIterator(\n      returnFiber,\n      currentFirstChild,\n      newChild,\n      expirationTime,\n    );\n  }\n\n  if (isObject) {\n    throwOnInvalidObjectType(returnFiber, newChild);\n  }\n\n  if (__DEV__) {\n    if (typeof newChild === 'function') {\n      warnOnFunctionType(returnFiber);\n    }\n  }\n  if (typeof newChild === 'undefined' && !isUnkeyedTopLevelFragment) {\n    // If the new child is undefined, and the return fiber is a composite\n    // component, throw an error. If Fiber return types are disabled,\n    // we already threw above.\n    switch (returnFiber.tag) {\n      case ClassComponent: {\n        if (__DEV__) {\n          const instance = returnFiber.stateNode;\n          if (instance.render._isMockFunction) {\n            // We allow auto-mocks to proceed as if they're returning null.\n            break;\n          }\n        }\n      }\n      // Intentionally fall through to the next case, which handles both\n      // functions and classes\n      // eslint-disable-next-lined no-fallthrough\n      case FunctionComponent: {\n        const Component = returnFiber.type;\n        invariant(\n          false,\n          '%s(...): Nothing was returned from render. This usually means a ' +\n            'return statement is missing. Or, to render nothing, ' +\n            'return null.',\n          Component.displayName || Component.name || 'Component',\n        );\n      }\n    }\n  }\n\n  // Remaining cases are all treated as empty.\n  return deleteRemainingChildren(returnFiber, currentFirstChild);\n}",lang:"js"}),r.createElement(i.Z,{code:"function reconcileSingleElement(\n  returnFiber: Fiber,\n  currentFirstChild: Fiber | null,\n  element: ReactElement,\n  expirationTime: ExpirationTime,\n): Fiber {\n  const key = element.key;\n  let child = currentFirstChild;\n  // \u66f4\u65b0\u65f6\u7528\u7684\uff0c\u5c31\u662f\u5728\u5df2\u6709tree\u4e0a\u64cd\u4f5c\n  while (child !== null) {\n    // TODO: If key === null and child.key === null, then this only applies to\n    // the first item in the list.\n    if (child.key === key) {\n      switch (child.tag) {\n        case Fragment: {\n          if (element.type === REACT_FRAGMENT_TYPE) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props.children);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n          break;\n        }\n        case Block:\n          if (enableBlocksAPI) {\n            let type = element.type;\n            if (type.$$typeof === REACT_LAZY_TYPE) {\n              type = resolveLazyType(type);\n            }\n            if (type.$$typeof === REACT_BLOCK_TYPE) {\n              // The new Block might not be initialized yet. We need to initialize\n              // it in case initializing it turns out it would match.\n              if (\n                ((type: any): BlockComponent<any, any>)._render ===\n                (child.type: BlockComponent<any, any>)._render\n              ) {\n                deleteRemainingChildren(returnFiber, child.sibling);\n                const existing = useFiber(child, element.props);\n                existing.type = type;\n                existing.return = returnFiber;\n                if (__DEV__) {\n                  existing._debugSource = element._source;\n                  existing._debugOwner = element._owner;\n                }\n                return existing;\n              }\n            }\n          }\n        // We intentionally fallthrough here if enableBlocksAPI is not on.\n        // eslint-disable-next-lined no-fallthrough\n        default: {\n          if (\n            child.elementType === element.type ||\n            // Keep this check inline so it only runs on the false path:\n            (__DEV__\n              ? isCompatibleFamilyForHotReloading(child, element)\n              : false)\n          ) {\n            deleteRemainingChildren(returnFiber, child.sibling);\n            const existing = useFiber(child, element.props);\n            existing.ref = coerceRef(returnFiber, child, element);\n            existing.return = returnFiber;\n            if (__DEV__) {\n              existing._debugSource = element._source;\n              existing._debugOwner = element._owner;\n            }\n            return existing;\n          }\n          break;\n        }\n      }\n      // Didn't match.\n      deleteRemainingChildren(returnFiber, child);\n      break;\n    } else {\n      deleteChild(returnFiber, child);\n    }\n    child = child.sibling;\n  }\n\n  if (element.type === REACT_FRAGMENT_TYPE) {\n    const created = createFiberFromFragment(\n      element.props.children,\n      returnFiber.mode,\n      expirationTime,\n      element.key,\n    );\n    created.return = returnFiber;\n    return created;\n  } else {\n    const created = createFiberFromElement(\n      element,\n      returnFiber.mode,\n      expirationTime,\n    );\n    created.ref = coerceRef(returnFiber, currentFirstChild, element);\n    created.return = returnFiber;\n    return created;\n  }\n}",lang:"js"}),r.createElement("h2",{id:"createfiberfromelement"},r.createElement(o.AnchorLink,{to:"#createfiberfromelement","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"createFiberFromElement"),r.createElement(i.Z,{code:"export function createFiberFromElement(\n  element: ReactElement,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n): Fiber {\n  let owner = null;\n  if (__DEV__) {\n    owner = element._owner;\n  }\n  const type = element.type;\n  const key = element.key;\n  const pendingProps = element.props;\n  const fiber = createFiberFromTypeAndProps(\n    type,\n    key,\n    pendingProps,\n    owner,\n    mode,\n    expirationTime,\n  );\n  if (__DEV__) {\n    fiber._debugSource = element._source;\n    fiber._debugOwner = element._owner;\n  }\n  return fiber;\n}",lang:"js"}),r.createElement(i.Z,{code:"export function createFiberFromTypeAndProps(\n  type: any, // React$ElementType\n  key: null | string,\n  pendingProps: any,\n  owner: null | Fiber,\n  mode: TypeOfMode,\n  expirationTime: ExpirationTime,\n): Fiber {\n  // \u4e0d\u786e\u5b9a\u7ec4\u4ef6\u7c7b\u578b\uff0c\u56e0\u4e3a\u4e0d\u7ba1\u51fd\u6570\u7ec4\u4ef6\u8fd8\u662f\u7c7b\u7ec4\u4ef6\uff0c\u90fd\u662ffunction\uff0c\u6240\u4ee5\u9700\u8981\u8fdb\u4e00\u6b65\u901a\u8fc7shouldConstruct\u786e\u5b9a\n  // \u7c7b\u7ec4\u4ef6=>ClassComponent\n  // \u51fd\u6570\u7ec4\u4ef6=>IndeterminateComponent\n  let fiberTag = IndeterminateComponent;\n  // The resolved type is set if we know what the final type will be. I.e. it's not lazy.\n  let resolvedType = type;\n  if (typeof type === 'function') {\n    if (shouldConstruct(type)) {\n      fiberTag = ClassComponent;\n      if (__DEV__) {\n        resolvedType = resolveClassForHotReloading(resolvedType);\n      }\n    } else {\n      if (__DEV__) {\n        resolvedType = resolveFunctionForHotReloading(resolvedType);\n      }\n    }\n  } else if (typeof type === 'string') {\n    // \u6d4f\u89c8\u5668\u7aef\u5c31\u662fDOM\u539f\u751f\u7ec4\u4ef6\n    fiberTag = HostComponent;\n  } else {\n    // \u4e0b\u9762\u7684\u662f\u4e00\u4e9b\u7279\u4f8b\u7ec4\u4ef6\n    getTag: switch (type) {\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(\n          pendingProps.children,\n          mode,\n          expirationTime,\n          key,\n        );\n      case REACT_DEBUG_TRACING_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= DebugTracingMode;\n        break;\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = Mode;\n        mode |= StrictMode;\n        break;\n      case REACT_PROFILER_TYPE:\n        return createFiberFromProfiler(pendingProps, mode, expirationTime, key);\n      case REACT_SUSPENSE_TYPE:\n        return createFiberFromSuspense(pendingProps, mode, expirationTime, key);\n      case REACT_SUSPENSE_LIST_TYPE:\n        return createFiberFromSuspenseList(\n          pendingProps,\n          mode,\n          expirationTime,\n          key,\n        );\n      default: {\n        if (typeof type === 'object' && type !== null) {\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n              fiberTag = ContextProvider;\n              break getTag;\n            case REACT_CONTEXT_TYPE:\n              // This is a consumer\n              fiberTag = ContextConsumer;\n              break getTag;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = ForwardRef;\n              if (__DEV__) {\n                resolvedType = resolveForwardRefForHotReloading(resolvedType);\n              }\n              break getTag;\n            case REACT_MEMO_TYPE:\n              fiberTag = MemoComponent;\n              break getTag;\n            case REACT_LAZY_TYPE:\n              fiberTag = LazyComponent;\n              resolvedType = null;\n              break getTag;\n            case REACT_BLOCK_TYPE:\n              fiberTag = Block;\n              break getTag;\n            case REACT_FUNDAMENTAL_TYPE:\n              if (enableFundamentalAPI) {\n                return createFiberFromFundamental(\n                  type,\n                  pendingProps,\n                  mode,\n                  expirationTime,\n                  key,\n                );\n              }\n              break;\n            case REACT_SCOPE_TYPE:\n              if (enableScopeAPI) {\n                return createFiberFromScope(\n                  type,\n                  pendingProps,\n                  mode,\n                  expirationTime,\n                  key,\n                );\n              }\n          }\n        }\n        let info = '';\n        if (__DEV__) {\n          if (\n            type === undefined ||\n            (typeof type === 'object' &&\n              type !== null &&\n              Object.keys(type).length === 0)\n          ) {\n            info +=\n              ' You likely forgot to export your component from the file ' +\n              \"it's defined in, or you might have mixed up default and \" +\n              'named imports.';\n          }\n          const ownerName = owner ? getComponentName(owner.type) : null;\n          if (ownerName) {\n            info += '\\n\\nCheck the render method of `' + ownerName + '`.';\n          }\n        }\n        invariant(\n          false,\n          'Element type is invalid: expected a string (for built-in ' +\n            'components) or a class/function (for composite components) ' +\n            'but got: %s.%s',\n          type == null ? type : typeof type,\n          info,\n        );\n      }\n    }\n    const fiber = createFiber(fiberTag, pendingProps, key, mode);\n    fiber.elementType = type;\n    fiber.type = resolvedType;\n    fiber.expirationTime = expirationTime;\n\n    return fiber;\n  }\n}",lang:"js"}),r.createElement("h2",{id:"\u5c0f\u7ed3-fiber-\u6811\u7684\u521b\u5efa"},r.createElement(o.AnchorLink,{to:"#\u5c0f\u7ed3-fiber-\u6811\u7684\u521b\u5efa","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"\u5c0f\u7ed3 fiber \u6811\u7684\u521b\u5efa"),r.createElement("p",null,"renderRootSync \u8c03\u7528 prepareFreshStack \u521d\u59cb\u5316\u5f53\u524d workInProgress"),r.createElement(i.Z,{code:"function prepareFreshStack() {\n  workInProgress = rootFiber;\n}",lang:"js"}),r.createElement("p",null,"workLoopSync \u4ece rootFiber \u5f00\u59cb\u5faa\u73af\u6267\u884c\u540c\u6b65\u4efb\u52a1:"),r.createElement(i.Z,{code:"function workLoopSync() {\n  // Already timed out, so perform work without checking if we need to yield.\n  while (workInProgress !== null) {\n    performUnitOfWork(workInProgress);\n  }\n}",lang:"js"}),r.createElement("p",null,"\u5f00\u59cb\u6309\u5355\u5143\u6267\u884c\u4efb\u52a1"),r.createElement(i.Z,{code:"function performUnitOfWork(unitOfWork: Fiber): void {\n  const current = unitOfWork.alternate;\n  let next;\n  if (enableProfilerTimer && (unitOfWork.mode & ProfileMode) !== NoMode) {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  } else {\n    next = beginWork(current, unitOfWork, renderExpirationTime);\n  }\n\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  if (next === null) {\n    completeUnitOfWork(unitOfWork);\n  } else {\n    workInProgress = next;\n  }\n}",lang:"js"}),r.createElement("p",null,"beginWork \u91cc\u9762\u5305\u542b\u5f88\u591a\u7c7b\u578b\u7ec4\u4ef6\u7684\u66f4\u65b0\u5904\u7406\uff0c"),r.createElement("p",null,"\u9996\u6b21 workInProgress \u662f rootFiber \u6240\u4ee5\uff0c\u5339\u914d HostRoot \u6267\u884c updateHostRoot \u66f4\u65b0"),r.createElement("p",null,"\u7b2c\u4e8c\u6b21\u8fdb\u5165 App \u662f ClassComponent \u7c7b\u578b\uff0c\u66f4\u65b0\u65f6\u4f1a\u8c03\u7528\u7ec4\u4ef6\u7684 render \u51fd\u6570",r.createElement("code",null,"nextChildren = instance.render();")," \u7136\u540e workInProgress.child = chlidFiber"),r.createElement(i.Z,{code:"function beginWork() {\n  switch (workInProgress.tag) {\n    case IndeterminateComponent: {\n    }\n    case LazyComponent: {\n    }\n    case FunctionComponent: {\n    }\n    case ClassComponent: {\n    }\n    case HostRoot:\n      return updateHostRoot(current, workInProgress, renderExpirationTime);\n    case HostComponent:\n    case HostText:\n    case SuspenseComponent:\n\n    case HostPortal:\n  }\n}",lang:"js"}),r.createElement("p",null,"updateHostRoot \u4e3b\u8981\u5e72\u4e24\u4ef6\u4e8b\uff0cClassComponent \u7b49\u540e\u9762\u770b\u7ec4\u4ef6\u66f4\u65b0\u8fc7\u7a0b\u65f6\u8be6\u7ec6\u5b66\u4e60"),r.createElement("p",null,"\u83b7\u53d6\u5230\u66f4\u65b0\u7684\u6570\u636e nextState"),r.createElement("p",null,"\u901a\u8fc7 createFiberFromElement(,,nextState.element)\u751f\u6210\u5b50 fiber"),r.createElement(i.Z,{code:"function updateHostRoot(current, workInProgress, renderExpirationTime) {\n  const updateQueue = workInProgress.updateQueue;\n  processUpdateQueue(workInProgress, nextProps, null, renderExpirationTime);\n  const nextState = workInProgress.memoizedState;\n  const nextChildren = nextState.element;\n  const root: FiberRoot = workInProgress.stateNode;\n  workInProgress.child = createFiberFromElement(,,nextState.element)\n  return workInProgress.child;\n}",lang:"js"}),r.createElement("p",null,"\u5230\u8fd9\u91cc beginWork \u6267\u884c\u7ed3\u675f\uff0c\u8fd4\u56de\u5230 performUnitOfWork \u4e2d"),r.createElement(i.Z,{code:"next = beginWork(current, unitOfWork, renderExpirationTime)\n// \u5176\u5b9e\nnext = workInProgress.child\n// \u4e5f\u5c31\u662f\nnext = createFiberFromElement(,,nextState.element)\n\n// \u91cd\u65b0\u8d4b\u503c\n workInProgress = next;\n\n//  \u4ee5child\u4e3aworkInProgress\u8fdb\u5165\u4e0b\u4e00\u8f6e\u5faa\u73af\nworkLoopSync()",lang:"js"}),r.createElement("h2",{id:"completeunitofwork"},r.createElement(o.AnchorLink,{to:"#completeunitofwork","aria-hidden":"true",tabIndex:-1},r.createElement("span",{className:"icon icon-link"})),"completeUnitOfWork"),r.createElement("p",null,"\u5176\u4e2d completeWork \u4f1a\u6839\u636e workInProgress \u7684\u7c7b\u578b"),r.createElement("p",null,"\u5982\u679c\u662f HostComponent\uff0c\u5c31\u662f DOM \u8282\u70b9\uff0c\u4f1a\u8c03\u7528\u6d4f\u89c8\u5668 DOM API \u521b\u5efa\u771f\u5b9e\u7684\u8282\u70b9\u5e76\u8d4b\u503c\u7ed9 workInProgress.stateNode"),r.createElement(i.Z,{code:"function completeUnitOfWork(unitOfWork: Fiber): void {\n  // Attempt to complete the current unit of work, then move to the next\n  // sibling. If there are no more siblings, return to the parent fiber.\n  let completedWork = unitOfWork;\n  do {\n    // The current, flushed, state of this fiber is the alternate. Ideally\n    // nothing should rely on this, but relying on it here means that we don't\n    // need an additional field on the work in progress.\n    const current = completedWork.alternate;\n    const returnFiber = completedWork.return;\n\n    // Check if the work completed or if something threw.\n    if ((completedWork.effectTag & Incomplete) === NoEffect) {\n      setCurrentDebugFiberInDEV(completedWork);\n      let next;\n      if (\n        !enableProfilerTimer ||\n        (completedWork.mode & ProfileMode) === NoMode\n      ) {\n        next = completeWork(current, completedWork, renderExpirationTime);\n      } else {\n        startProfilerTimer(completedWork);\n        next = completeWork(current, completedWork, renderExpirationTime);\n        // Update render duration assuming we didn't error.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n      }\n      resetCurrentDebugFiberInDEV();\n      resetChildExpirationTime(completedWork);\n\n      if (next !== null) {\n        // Completing this fiber spawned new work. Work on that next.\n        workInProgress = next;\n        return;\n      }\n\n      if (\n        returnFiber !== null &&\n        // Do not append effects to parents if a sibling failed to complete\n        (returnFiber.effectTag & Incomplete) === NoEffect\n      ) {\n        // Append all the effects of the subtree and this fiber onto the effect\n        // list of the parent. The completion order of the children affects the\n        // side-effect order.\n        if (returnFiber.firstEffect === null) {\n          returnFiber.firstEffect = completedWork.firstEffect;\n        }\n        if (completedWork.lastEffect !== null) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = completedWork.firstEffect;\n          }\n          returnFiber.lastEffect = completedWork.lastEffect;\n        }\n\n        // If this fiber had side-effects, we append it AFTER the children's\n        // side-effects. We can perform certain side-effects earlier if needed,\n        // by doing multiple passes over the effect list. We don't want to\n        // schedule our own side-effect on our own list because if end up\n        // reusing children we'll schedule this effect onto itself since we're\n        // at the end.\n        const effectTag = completedWork.effectTag;\n\n        // Skip both NoWork and PerformedWork tags when creating the effect\n        // list. PerformedWork effect is read by React DevTools but shouldn't be\n        // committed.\n        if (effectTag > PerformedWork) {\n          if (returnFiber.lastEffect !== null) {\n            returnFiber.lastEffect.nextEffect = completedWork;\n          } else {\n            returnFiber.firstEffect = completedWork;\n          }\n          returnFiber.lastEffect = completedWork;\n        }\n      }\n    } else {\n      // This fiber did not complete because something threw. Pop values off\n      // the stack without entering the complete phase. If this is a boundary,\n      // capture values if possible.\n      const next = unwindWork(completedWork, renderExpirationTime);\n\n      // Because this fiber did not complete, don't reset its expiration time.\n\n      if (\n        enableProfilerTimer &&\n        (completedWork.mode & ProfileMode) !== NoMode\n      ) {\n        // Record the render duration for the fiber that errored.\n        stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);\n\n        // Include the time spent working on failed children before continuing.\n        let actualDuration = completedWork.actualDuration;\n        let child = completedWork.child;\n        while (child !== null) {\n          actualDuration += child.actualDuration;\n          child = child.sibling;\n        }\n        completedWork.actualDuration = actualDuration;\n      }\n\n      if (next !== null) {\n        // If completing this work spawned new work, do that next. We'll come\n        // back here again.\n        // Since we're restarting, remove anything that is not a host effect\n        // from the effect tag.\n        next.effectTag &= HostEffectMask;\n        workInProgress = next;\n        return;\n      }\n\n      if (returnFiber !== null) {\n        // Mark the parent fiber as incomplete and clear its effect list.\n        returnFiber.firstEffect = returnFiber.lastEffect = null;\n        returnFiber.effectTag |= Incomplete;\n      }\n    }\n\n    const siblingFiber = completedWork.sibling;\n    // \u5904\u7406\u5144\u5f1f\u8282\u70b9\uff0cworkLoopSync\u8fdb\u5165\u4e0b\u4e00\u6b21\u5faa\u73af\n    if (siblingFiber !== null) {\n      // If there is more work to do in this returnFiber, do that next.\n      workInProgress = siblingFiber;\n      return;\n    }\n    // Otherwise, return to the parent\n    // \u6ca1\u6709\u5144\u5f1f\u8282\u70b9\u8fd4\u56de\u7236\u7ea7\uff0cworkLoopSync\u8fdb\u5165\u4e0b\u4e00\u6b21\u5faa\u73af\n    completedWork = returnFiber;\n    // Update the next thing we're working on in case something throws.\n    workInProgress = completedWork;\n    //\n  } while (completedWork !== null);\n\n  // We've reached the root.\n  if (workInProgressRootExitStatus === RootIncomplete) {\n    workInProgressRootExitStatus = RootCompleted;\n  }\n}",lang:"js"}))))}}]);