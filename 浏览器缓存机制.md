---
route: /browser-cache
---

## 强缓存

### Expires <sub>HTTP1.0</sub>

请求资源时服务端返回

Response Headers

```
Expires: Wed, 31 Jan 2029 06:11:25 GMT
```

表示 2029 06:11:25 时间之前，再次请求该资源就直接使用缓存
Expires 是 http 1.0 标准，其值为 GMT 格林威治时间
缺点：是客户端和服务端时间不统一，缓存控制就会出现问题

### Cache-Control

Response Headers

```
Cache-Control: max-age=315360000
```

表示 315360000 秒内缓存有效，Cache-Control 优先级高于 Expires
由于 Expires 缓存的缺点，所以又弄了个 max-age，使用相对时间代替绝对时间，Cache-Control 还支持以下设置

    - no-cache 在使用缓存前，向服务器确认缓存新鲜度，并不是不使用缓存
    - no-store 不使用缓存
    - public 所有用户都可以缓存
    - private 禁止代理服务器如CDN缓存
    - max-age:60 60秒内都使用缓存
    - s-maxage:覆盖max-age,只在代理服务器生效,比如60秒内CDN更新了内容，也不会请求CDN
    - max-stale[steɪl]:30， 30秒内即使缓存失效也使用
    - min-fresh：30， 30内不使用缓存

## 协商缓存

### Last-Modified <sub>HTTP1.0</sub>



Response Headers
文件最后修改时间
缺点：

- 文件修改了，但是其内容没有变化
- 1s 高频率修改文件内容

### If-Modified-Since <sub>HTTP1.1</sub>

Request Headers
携带上次 res 返回的 Last-Modified 值

## If-UnModified-Since <sub>HTTP1.1</sub>

和 If-Modified-Sline 类似，区别是如果没有命中，返回 412，可以优化并发请求，如：多人同时 POST 提交一份文档编辑请求，如果服务端资源已经被修改，其他提交就是被 412 拒绝

### Etag/If-None-Match <sub>HTTP1.1</sub>

```
etag: W/"5df1e2dd-4713"
```

访问一个资源如一个 Image，服务器会根据 Image 生成一个资源指纹 Etag，每当资源发生变化后会重新生成，当首次请求该资源时 Response 会返回 Etag，后续再请求该资源时 Reuqest 携带上次 Response 返回的 Etag,服务器接受到 Etag 后进行验证，决定如何使用缓存

```
If-None-Match:W/"5df1e2dd-4713"
```

ETag 优先级高于 Last-Modified

## 缓存位置

- 内存 Memory Cache
- 硬盘 Disk Cache
- Service Worker

### Memory Cache

内存中的缓存读取速度快，但生命周期短，关闭浏览器就消失了，且浏览器可分配的内存是有限制的

### Disk Cache

速度相对内存慢，用户不主动清除缓存理论上缓存会一直存在

### Service Worker

强大的 sw 可以拦截所有请求，并决定是否使用缓存还是走正常请求流程，缓存可以由前端全权掌控，可以避免 304 请求

### 缓存读取

1.Memory Cache
2.Disk Cache

## 避免使用缓存

Request Headers

Cache-Control:no-store
