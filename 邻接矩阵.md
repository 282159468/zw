---
route: /dag
---

## 邻接矩阵

可以用来表示有向图和无向图，有向图和无向图这个概念很容易理解，但是哪些场景可以看成图，或者邻接矩阵能应用于哪些实际业务中，这点是我觉得比较难的

## 无向图

比某图有顶点

v0 v1 v2 v3 v4

关系
v0-v3
v1-v3
v1-v4

邻接矩阵数组中 0 表示节点之间没有关系，1 则表示有关系，具有以下特点

- 数组长度是节点数量的平方
- 斜边上的值肯定为 0，因为同行同列对应着同一个节点，所以不会有关系
- 数据根据斜边对称

上面说的斜边是从左上到右下的边

```js
const arr = [
// // v0  v1  v2  v3  v4
//    0,  0,  0,  1,  0, // v0
//    0,  0,  0,  1,  1, // v1
//    0,  0,  0,  0,  0, // v2
//    1,  1,  0,  0,  0, // v3
//    0,  1,  0,  0,  0, // v4
// ]
```

通过一个类实现

```js
class Adjoin {
  constructor(vertex) {
    this.vertex = vertex;
    this.quantity = vertex.length;
    this.init();
  }

  init() {
    this.adjoinArray = Array.from({
      length: this.quantity * this.quantity,
    });
  }

  getAdjoinVertexs(id) {
    const pIndex = this.vertex.indexOf(id);
    const vertexs = [];
    this.adjoinArray.forEach((flag, index) => {
      if (
        flag === 1 &&
        index >= this.vertex.length * pIndex &&
        index < this.vertex.length * (pIndex + 1)
      ) {
        vertexs.push(this.vertex[index % this.vertex.length]);
      }
    });
    return vertexs;
  }

  setAdjoinVertexs(id, sides) {
    const pIndex = this.vertex.indexOf(id);
    sides.forEach((item) => {
      const index = this.vertex.indexOf(item);
      this.adjoinArray[this.vertex.length * pIndex + index] = 1;
    });
  }
}

// 创建邻接矩阵

const join = new Adjoin(["v0", "v1", "v2", "v3", "v4"]);

// 添加几条边
join.setAdjoinVertexs("v0", ["v3"]);
join.setAdjoinVertexs("v1", ["v3", "v4"]);
console.log(join.getAdjoinVertexs("v0"));
console.log(join.getAdjoinVertexs("v1"));
```

如果使用二维数据表示邻接矩阵操作数据会更方便些
